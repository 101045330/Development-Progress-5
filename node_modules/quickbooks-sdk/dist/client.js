"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const models_1 = require("./models");
const config_1 = require("./config");
const qs = require('qs');
class QBORequest {
    constructor(props = {}) {
        this.url = "";
        this.method = "get";
        this.params = {};
        if (props.url !== undefined) {
            this.url = props.url;
        }
        if (props.method !== undefined) {
            this.method = props.method;
        }
        if (props.params !== undefined) {
            this.params = props.params;
        }
    }
}
class QBOClient {
    constructor(clientId, clientSecret, companyId, sandbox = true) {
        this.sandboxUrl = "https://sandbox-quickbooks.api.intuit.com";
        this.productionUrl = "https://quickbooks.api.intuit.com";
        this.baseUrl = "";
        this.clientId = "";
        this.clientSecret = "";
        this.companyId = "";
        this.accessToken = "";
        this.refreshToken = "";
        this.environment = "sandbox";
        this.minorversion = "8";
        this.onRefreshListener = null;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.companyId = companyId;
        this.environment = sandbox ? "sandbox" : "production";
        if (this.environment === "production") {
            this.baseUrl = this.productionUrl;
        }
        else {
            this.baseUrl = this.sandboxUrl;
        }
    }
    setAccessToken(token, refreshToken = "") {
        this.accessToken = token;
        this.refreshToken = refreshToken;
    }
    getAccessToken() {
        return this.accessToken;
    }
    getEnvironment() {
        return this.environment;
    }
    getCompanyId() {
        return this.companyId;
    }
    setOnRefreshToken(listener) {
        this.onRefreshListener = listener;
    }
    getRefreshToken() {
        console.log('[QBO] getRefreshToken()');
        const refreshUrl = config_1.config.accessTokenUri;
        const authToken = require('btoa')(this.clientId + ":" + this.clientSecret);
        const postData = qs.stringify({
            grant_type: "refresh_token",
            refresh_token: this.refreshToken
        });
        return axios_1.default({
            method: 'post',
            url: refreshUrl,
            data: postData,
            headers: {
                'Authorization': 'Basic ' + authToken,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        })
            .then((token) => {
            return token.data;
        })
            .catch((error) => {
            console.log(`[QBO] refresh token failed with error`, error.message);
            console.log(error.response.data);
            console.log(error.response.status);
            console.log(error.response.statusText);
            //console.log(error.response.data);
            throw error;
        });
    }
    endPoint(path, includeMinorVersion = true) {
        let returnUrl = `${this.baseUrl}/v3/company/${this.companyId}${path}`;
        if (includeMinorVersion) {
            if (path.indexOf('?') === -1) {
                returnUrl += "?minorversion=" + this.minorversion;
            }
            else {
                returnUrl += "&minorversion=" + this.minorversion;
            }
        }
        return returnUrl;
    }
    /**
     * Sends a request to QuickBooks Server.
     * This method checks for the response. If it responds with 401,
     * then tries to refresh the Access Token and the retries the request.
     */
    sendRequest(request) {
        const checkUnathorized = (error) => {
            if (error.response !== undefined) {
                if (error.response.status === 401) {
                    // handle unauthorized error code
                    console.log("[QBO] request failed due to 401 response code...");
                    return handleUnauthorizedError(error);
                }
            }
            // not 401: throw error
            return Promise.reject(error);
        };
        const handleUnauthorizedError = (error) => {
            return this.getRefreshToken()
                .then((data) => {
                console.log("[QBO] token updated...");
                this.accessToken = data.access_token;
                this.refreshToken = data.refresh_token;
                if (this.onRefreshListener) {
                    this.onRefreshListener(data.access_token, data.refresh_token);
                }
                return true;
            });
        };
        const getHeaders = (method) => {
            if (method === "get" || method === "delete") {
                return {
                    'Authorization': 'Bearer ' + this.accessToken,
                    'Accept': 'application/json'
                };
            }
            if (method === "post" || method === "put") {
                return {
                    'Authorization': 'Basic ' + this.accessToken,
                    'Content-Type': 'application/x-www-form-urlencoded'
                };
            }
        };
        const headers = getHeaders(request.method);
        const params = {
            method: request.method,
            url: request.url,
            data: request.params,
            headers: headers
        };
        return axios_1.default(params)
            .then((response) => {
            return response.data;
        })
            .catch((error) => {
            return checkUnathorized(error)
                .then((result) => {
                console.log("[QBO] retrying request...");
                // update headers (with new Authentication params)
                params.headers = getHeaders(request.method);
                return axios_1.default(params)
                    .then((response) => {
                    console.log("[QBO] request retry succedded.");
                    return response.data;
                })
                    .catch((error) => {
                    console.log("[QBO] request failed again: ", error.message);
                    throw error;
                });
            })
                .catch((error) => {
                console.log("[QBO] request failed: ", error.message);
                throw error;
            });
        });
    }
    /**
     * Creates a new Invoice in QBO.
     * @link https://developer.intuit.com/docs/api/accounting/invoice
     * @param customerId
     * @param items
     * @param extra
     */
    createInvoice(customerId, items, extra = {}) {
        const lines = items.map((item) => {
            return item.getPayload();
        });
        const url = this.endPoint("/invoice");
        const payload = {
            "Line": lines,
            "CustomerRef": {
                "value": customerId
            }
        };
        if (extra.DocNumber !== undefined) {
            payload["DocNumber"] = extra.DocNumber;
        }
        if (extra.SalesTerm !== undefined) {
            payload["SalesTermRef"] = {
                value: extra.SalesTerm.value
            };
        }
        if (extra.Memo !== undefined) {
            payload["CustomerMemo"] = {
                value: extra.Memo
            };
        }
        /**
         * @deprecated
         */
        if (extra.AllowOnlineACHPayment === true) {
            payload["AllowOnlineACHPayment"] = true;
        }
        if (extra.AllowOnlinePayment === true) {
            payload["AllowOnlineACHPayment"] = true;
            payload["AllowOnlineCreditCardPayment"] = true;
        }
        if (extra.BillEmail) {
            payload["BillEmail"] = {
                "Address": extra.BillEmail
            };
        }
        if (extra.BillEmailCc) {
            payload["BillEmailCc"] = {
                "Address": extra.BillEmailCc
            };
        }
        if (extra.BillEmailBcc) {
            payload["BillEmailBcc"] = {
                "Address": extra.BillEmailBcc
            };
        }
        if (extra.TxnDate) {
            payload["TxnDate"] = extra.TxnDate;
        }
        return axios_1.default({
            method: 'post',
            url: url,
            data: payload,
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + this.accessToken
            }
        })
            .then((response) => {
            console.log("[QBO] Invoice Created.");
            return new models_1.QBOInvoice(response.data);
        });
    }
    /**
     * Retrieves the full list of Customers from QuickBooks API.
     * @link https://developer.intuit.com/docs/api/accounting/customer
     */
    getAllCustomers() {
        const query = encodeURIComponent("select * from Customer where Active in (true, false) MAXRESULTS 500");
        const request = new QBORequest({
            url: this.endPoint("/query?query=" + query),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            return data.QueryResponse.Customer
                .map((item) => {
                return new models_1.QBOCustomer(item);
            });
        });
    }
    /**
     * Retrieves the list of Customers that are marked as 'active' from QuickBooks API.
     * @link https://developer.intuit.com/docs/api/accounting/customer
     */
    getActiveCustomers() {
        const query = encodeURIComponent("select * from Customer where Active=true MAXRESULTS 500");
        const request = new QBORequest({
            url: this.endPoint("/query?query=" + query),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            return data.QueryResponse.Customer
                .map((item) => {
                return new models_1.QBOCustomer(item);
            });
        });
    }
    /**
     * Retrieves the list of Customers that are marked as 'archived' from QuickBooks API.
     * @link https://developer.intuit.com/docs/api/accounting/customer
     */
    getArchivedCustomers() {
        const query = encodeURIComponent("select * from Customer where Active=false MAXRESULTS 500");
        const request = new QBORequest({
            url: this.endPoint("/query?query=" + query),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            return data.QueryResponse.Customer
                .map((item) => {
                return new models_1.QBOCustomer(item);
            });
        });
    }
    /**
     * Retrieves a Customer by name from QuickBooks API.
     * @link https://developer.intuit.com/docs/api/accounting/customer
     */
    getCustomer(name) {
        const query = encodeURIComponent(`select * from Customer where CompanyName='${name}'`);
        const request = new QBORequest({
            url: this.endPoint("/query?query=" + query),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            const response = data.QueryResponse;
            if (!response.Customer || response.Customer.length === 0) {
                throw new Error(`Customer "${name}" not found.`);
            }
            const customer = new models_1.QBOCustomer(response.Customer[0]);
            return customer;
        });
    }
    getCustomerById(customerId) {
        const request = new QBORequest({
            url: this.endPoint(`/customer/${customerId}`),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            if (!data.Customer) {
                throw new Error(`Customer "${customerId}" not found.`);
            }
            const customer = new models_1.QBOCustomer(data.Customer);
            return customer;
        });
    }
    /**
     * Gets a company's hierarchy based on parent/children relationship between them.
     * @todo parent/children relationship is hardcoded for Allen & Co
     */
    getCustomerHierarchy(name) {
        let query = encodeURIComponent(`select * from Customer where FullyQualifiedName like '${name}%'`);
        // TODO: find a way to get the relationship between children companies
        //if( name.toLowerCase().startsWith( 'Allen & Co'.toLowerCase() ) ) {
        //	query = encodeURIComponent(`select * from Customer where Id in ('612', '633')`);
        //}
        const url = this.endPoint("/query?query=" + query, true);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            const response = data.QueryResponse;
            // check errors
            if (!response.Customer || response.Customer.length === 0) {
                throw new Error(`Customer "${name}" not found.`);
            }
            // map response to QBOCustomer[]
            let customers = response.Customer.map((item) => {
                return new models_1.QBOCustomer(item);
            });
            return customers;
        })
            .then((customers) => {
            // build customers tree
            for (let i in customers) {
                let customer = customers[i];
                if (customer.parentId > 0) {
                    let parent = customers.find((c) => {
                        return c.id === customer.parentId;
                    });
                    if (parent) {
                        parent.childrenCustomers.push(customer);
                        customer.parentId = parent.id;
                        customer.parentCustomer = parent;
                        customer.companyCount = customers.length;
                        parent.companyCount = customers.length;
                        //customer.parentCustomer = parent[0];
                    }
                }
            }
            return customers;
        })
            .then((customers) => {
            // return top customer (no ParentRef)
            let root = customers.find((i) => {
                return i.parentId === 0;
            });
            if (!root) {
                throw new Error("Customer not found");
            }
            return root;
        });
    }
    /**
     * Gets a service given its id.
     * @param serviceId
     */
    getServiceItemById(serviceId) {
        const url = this.endPoint(`/item/${serviceId}`);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            let service = new models_1.QBOService(data.Item);
            return service;
        });
    }
    /**
     * Get a list of items whose parent category is the specified.
     * Useful for finding the developer's service which share a common parent category.
     * @param categoryId
     */
    getServicesByCategory(categoryId) {
        const query = encodeURIComponent(`select * from Item where ParentRef='${categoryId}' and Active in (true, false) MAXRESULTS 500`);
        const url = this.endPoint("/query?query=" + query);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            const response = data.QueryResponse;
            if (response.Item) {
                return response.Item.map((item) => {
                    return new models_1.QBOService(item);
                });
            }
            return [];
        });
    }
    /**
     * Retrieves a Service by SKU from QuickBooks API.
     * @link https://developer.intuit.com/docs/api/accounting/item
     */
    getServiceBySKU(sku) {
        const query = encodeURIComponent(`select * from Item where Sku='${sku}'`);
        const url = this.endPoint("/query?query=" + query);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            if (data.QueryResponse && data.QueryResponse.Item) {
                return data.QueryResponse.Item;
            }
            return [];
        })
            .then((items) => {
            if (items !== undefined && items.length > 0) {
                const service = new models_1.QBOService(items[0]);
                //service.sku = sku;
                return service;
            }
            else {
                return null;
            }
        });
    }
    /**
     * Get the last invoice created for a Customer.
     * @param clientId
     */
    getLastClientInvoice(clientId) {
        const query = encodeURIComponent(`select * from Invoice where CustomerRef='${clientId}' orderby Id desc MAXRESULTS 1`);
        const url = this.endPoint("/query?query=" + query);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            if (data.QueryResponse && data.QueryResponse.Invoice) {
                return data.QueryResponse.Invoice;
            }
            return [];
        })
            .then((items) => {
            if (items.length > 0) {
                const invoice = new models_1.QBOInvoice(items[0]);
                return invoice;
            }
            return null;
        });
    }
    getCustomerInvoices(clientId, startDate = '', endDate = '') {
        let query = encodeURIComponent(`select * from Invoice where CustomerRef='${clientId}' MAXRESULTS 500`);
        if (startDate !== '') {
            query += ` and TxnDate >= '${startDate}'`;
        }
        if (endDate !== '') {
            query += ` and TxnDate <= '${endDate}'`;
        }
        query += ` orderby TxnDate desc`;
        const url = this.endPoint("/query?query=" + query);
        const request = new QBORequest({
            url: url,
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            if (data.QueryResponse && data.QueryResponse.Invoice) {
                return data.QueryResponse.Invoice;
            }
            return [];
        })
            .then((items) => {
            if (items.length > 0) {
                return items.map((item) => {
                    return new models_1.QBOInvoice(item);
                });
            }
            else {
                return [];
            }
        });
    }
    batchQueries(requests) {
        const url = this.endPoint("/batch");
        const payload = {
            "BatchItemRequest": requests.map((request) => {
                return request.payload();
            })
        };
        /*
        console.log(`[QBO] Batch`, {
            method: 'post',
            url: url,
            data: payload
        });*/
        return axios_1.default({
            method: 'post',
            url: url,
            headers: {
                'Accept': 'application/json',
                'Authorization': 'Bearer ' + this.accessToken
            },
            data: payload
        })
            .then((response) => {
            return response.data;
        })
            .then((data) => {
            return data.BatchItemResponse.map((item) => {
                return new models_1.QBOBatchItemResponse(item);
            });
        });
    }
    /**
     * Retrieves the list of Terms for the Invoices.
     * @link https://developer.intuit.com/docs/api/accounting/term
     */
    getTerms() {
        const query = encodeURIComponent("select * from Term");
        const request = new QBORequest({
            url: this.endPoint("/query?query=" + query),
            method: 'get'
        });
        return this.sendRequest(request)
            .then((data) => {
            return data.QueryResponse.Term
                .map((item) => {
                return new models_1.QBOTerms(item);
            });
        });
    }
    /**
     * Retrieves the report of Profit and Loss.
     * @link https://developer.intuit.com/docs/api/accounting/profit-and-loss-detail
     * @param startDate
     * @param endDate
     */
    getProfitAndLoss(startDate, endDate) {
        const request = new QBORequest({
            url: this.endPoint(`/reports/ProfitAndLossDetail?start_date=${startDate}&end_date=${endDate}`),
            method: 'get'
        });
        return this.sendRequest(request);
    }
}
exports.QBOClient = QBOClient;
